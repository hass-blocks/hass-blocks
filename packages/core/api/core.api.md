## API Report File for "@hass-blocks/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { CallServiceCommand } from '@hass-blocks/hass-ts';
import type { Event as Event_2 } from '@hass-blocks/hass-ts';
import type { HassArea } from '@hass-blocks/hass-ts';
import type { HassConfig } from '@hass-blocks/hass-ts';
import { IHomeAssistant } from '@hass-blocks/hass-ts';
import type { IMQTTConnection } from '@hass-blocks/hass-mqtt';
import type { Service } from '@hass-blocks/hass-ts';
import type { State } from '@hass-blocks/hass-ts';

// @public
export const action: <I = void, O = void>(config: IActionConfig<I, O>) => Block<I, O>;

// @public
export const area: <I extends string>(id: I, name?: string) => IArea<I>;

// @public
export const assertion: <I = void, O = void>(config: IAssertionConfig<I, O>) => Block<I, O>;

// @public
export const automation: <const A extends readonly Block<unknown, unknown>[], I = GetSequenceInput<A>, O = GetSequenceOutput<A>>(config: IAutomationConfig<A, I, O>) => Block<I, O>;

// @public
export interface AutomationRegistered extends BaseHassBlocksEvent<'automation-registered'> {
    block: SerialisedBlock;
    name: string;
}

// @public
export interface BaseHassBlocksEvent<T extends string> {
    eventType: T;
    id: string;
    timestamp: string;
}

// @public
export abstract class Block<I = void, O = void> implements IBlock<I, O> {
    constructor(
    id: string, targets: ITarget[] | undefined,
    children?: IBlocksNode[] | undefined, _trigger?: (ITrigger | ITrigger[]) | undefined);
    readonly children?: IBlocksNode[] | undefined;
    readonly id: string;
    initialise(client: IFullBlocksClient, mqtt: IMQTTConnection): Promise<void>;
    abstract readonly name: string;
    abstract run(client: IHass, input: I, events?: IEventBus, triggerId?: string): Promise<BlockOutput<O>> | BlockOutput<O>;
    toJson(): {
        type: string;
        id: string;
        name: string;
    };
    get trigger(): ITrigger | ITrigger[];
    set trigger(trigger: ITrigger | ITrigger[]);
    abstract readonly typeString: string;
}

// @public
export interface BlockFailed extends LifeCycleEvent<'block-failed'> {
    error: Error;
    message: string;
    parent?: SerialisedBlock;
    type: string;
}

// @public
export interface BlockFinished<O = unknown> extends LifeCycleEvent<'block-finished'> {
    output: BlockOutput<O>;
    parent?: SerialisedBlock;
    type: string;
}

// @public
export type BlockOutput<O> = ContinueOutput<O> | StopOutput | ConditionResult<O>;

// @public
export interface BlockPending extends LifeCycleEvent<'block-pending'> {
    parent?: SerialisedBlock;
    triggeredBy?: ITrigger;
    type: string;
}

// @public
export type BlockRetainType<A extends readonly Block<unknown, unknown>[]> = A extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? readonly [
Block<InputType<First>, OutputTypeKeepPromise<First>>,
...BlockRetainType<Rest>
] : readonly [];

// @public
export interface BlockStarted extends LifeCycleEvent<'block-started'> {
    parent?: SerialisedBlock;
    triggeredBy?: ITrigger;
    type: string;
}

// @public
export type BlockTypeIsCompatibleWithSequence<TFirstBlock, TSequenceInput> = [
TFirstBlock
] extends [
TSequenceInput extends void ? MustIncludeUndefined<TFirstBlock> : Partial<TSequenceInput>
] ? true : false;

// @public
export type CheckOutput = readonly Block<unknown, unknown>[] | DoRecurse<unknown, unknown, readonly Block<unknown, unknown>[], readonly Block<unknown, unknown>[]> | SequenceCompatibilityError<unknown, unknown, readonly Block<unknown, unknown>[], readonly Block<unknown, unknown>[], string>;

// @public
export type CheckScenarios<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = SinglePassBlock<TSequence, TBefore> extends never ? SingleGeneralBlock<TSequence, TBefore, TInput, TOutput> extends never ? TwoPassBlocks<TSequence, TBefore> extends never ? MultiPassSequence<TSequence, TBefore, TInput, TOutput> extends never ? NonPassSequence<TSequence, TBefore, TInput, TOutput> extends never ? SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'No compatible sequences found'> : NonPassSequence<TSequence, TBefore, TInput, TOutput> : MultiPassSequence<TSequence, TBefore, TInput, TOutput> : TwoPassBlocks<TSequence, TBefore> : SingleGeneralBlock<TSequence, TBefore, TInput, TOutput> : SinglePassBlock<TSequence, TBefore>;

// @public
export const combine: <T extends ReadonlyArray<IArea> | ReadonlyArray<IEntity> | ReadonlyArray<IDevice>>(...items: T) => T[number];

// @public
export const concurrently: <A extends readonly Block<unknown, unknown>[]>(...actions: A) => Block<InputType<A[number]>, OutputType<A[number]>[]>;

// @public
export interface ConditionResult<O> {
    conditionResult: boolean;
    continue: true;
    output: O;
    outputType: 'conditional';
}

// @public
export interface ContinueOutput<O> {
    continue: true;
    output: O;
    outputType: 'block';
}

// @public
export type DoRecurse<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = {
    __recurse: true;
    in: TInput;
    out: TOutput;
    sequence: TSequence;
    before: TBefore;
};

// @public
export const entity: <I extends `${string}.${string}`>(id: I, friendlyName?: string) => IEntity<I>;

// @public
export class ExecutionAbortedError extends HassBlocksError {
    constructor(name: string);
}

// @public
export enum ExecutionMode {
    Parallel = "Parallel",
    Queue = "Queue",
    Restart = "Restart"
}

// @public
export type ExtractOutput<TAny> = TAny extends Promise<infer TPromiseType> ? ExtractOutput<TPromiseType> : TAny extends Exclude<BlockOutput<infer TBlockType>, StopOutput> ? TBlockType : never;

// @public
export interface GeneralFailure extends BaseHassBlocksEvent<'generalFailure'> {
    error: Error;
    message: string;
}

// @public
export type GetOutputs<T extends readonly Block<unknown, unknown>[]> = T extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends Block<unknown, unknown>[]
] ? readonly [OutputType<First>, ...GetOutputs<Rest>] : readonly [];

// @public
export type GetSequenceInput<T extends ReadonlyArray<unknown>> = T extends readonly [Block<Pass, Pass>] ? Pass : T extends readonly [infer Only extends Block<unknown, unknown>] ? InputType<Only> : T extends readonly [infer First, ...infer Rest] ? First extends Block<Pass, Pass> ? GetSequenceInput<Rest> : First extends Block<unknown, unknown> ? InputType<First> : ['Item wasnt a block'] : ['No valid array remaining'];

// @public
export type GetSequenceOutput<T extends ReadonlyArray<unknown>> = T extends readonly [Block<Pass, Pass>] ? Pass : T extends readonly [infer Only extends Block<unknown, unknown>] ? OutputType<Only> : T extends readonly [...infer Rest, infer Last] ? Last extends Block<Pass, Pass> ? GetSequenceOutput<Rest> : Last extends Block<unknown, unknown> ? OutputType<Last> : ['Item wasnt a block'] : ['No valid arrray remaining'];

// @public
export class HassBlocksError extends Error {
    constructor(message: string, cause?: unknown);
}

// @public
export type HassBlocksEvent = AutomationRegistered | GeneralFailure | LogEvent | StateChanged | BlockFailed | BlockFinished | BlockPending | BlockStarted | SequenceAborted | LoadPluginsStart | LoadPluginStart | LoadPluginsFinished | LoadPluginFinished;

// @public
export type HassContext = {
    id: string;
    user_id: string | null;
    parent_id: string | null;
};

// @public
export type HassEntity = HassEntityBase & {
    attributes: {
        [key: string]: any;
    };
};

// @public
export type HassEntityAttributeBase = {
    friendly_name?: string;
    unit_of_measurement?: string;
    icon?: string;
    entity_picture?: string;
    supported_features?: number;
    hidden?: boolean;
    assumed_state?: boolean;
    device_class?: string;
    state_class?: string;
    restored?: boolean;
};

// @public
export type HassEntityBase = {
    entity_id: string;
    state: string;
    last_changed: string;
    last_updated: string;
    attributes: HassEntityAttributeBase;
    context: HassContext;
};

// @public
export type HassEventBase = {
    origin: string;
    time_fired: string;
    context: HassContext;
};

// @public
export interface IActionConfig<I = void, O = void> extends IBaseBlockConfig {
    callback: ((client: IHass, input: I) => O) | ((client: IHass, input: I) => Promise<O>);
}

// @public
export interface IArea<I extends string = string> extends ITarget {
    targetIds: {
        area_id: I[];
    };
}

// @public
export interface IAssertionConfig<I, O> extends IBaseBlockConfig {
    readonly predicate: (client: IHass, input?: I) => Promise<boolean> | boolean | {
        result: boolean;
        output: O;
    } | Promise<{
        result: boolean;
        output: O;
    }>;
}

// @public
export interface IAutomationConfig<A extends readonly Block<unknown, unknown>[], I = GetSequenceInput<A>, O = GetSequenceOutput<A>> extends IBaseBlockConfig {
    mode?: ExecutionMode;
    then: (BlockRetainType<A> & A & ValidateSequence<I, O, A>) | Block<I, O>;
    when?: ITrigger | ITrigger[];
}

// @public
export interface IBaseBlockConfig {
    readonly id?: string;
    readonly name: string;
    readonly targets?: ITarget[];
}

// @public
export interface IBlock<I = void, O = void> extends IBlocksNode {
    id: string;
    name: string;
    run(hass: IHass, input: I, events?: IEventBus, triggerId?: string): Promise<BlockOutput<O>> | BlockOutput<O>;
    toJson(): SerialisedBlock;
    trigger: ITrigger | ITrigger[];
    typeString: string;
}

// @public
export interface IBlocksConfig {
    client?: IHomeAssistant;
    logger?: ILogger;
    plugins?: IBlocksPlugin[];
}

// @public
export interface IBlocksConnection {
    registry: IBlocksRegistry;
}

// @public
export interface IBlocksNode {
    children?: IBlocksNode[] | undefined;
    id: string;
    initialise(client: IHass, mqtt: IMQTTConnection): Promise<void>;
    name: string;
}

// @public
export interface IBlocksPlugin {
    load(args: IPluginArgs): Promise<void>;
    readonly name: string;
}

// @public
export interface IBlocksRegistry {
    registerAutomation(...automation: IBlock<unknown, unknown>[]): Promise<void>;
}

// @public
export interface ICallServiceParams {
    data?: Record<string, unknown>;
    domain: string;
    service: string;
    target?: {
        entity_id?: string | string[];
        area_id?: string | string[];
        device_id?: string | string[];
    };
}

// @public
export interface IDevice extends ITarget {
    targetIds: {
        device_id: string[];
    };
}

// @public
export interface IDoWhileConfig<TInput = void, TOutput = void, TBlockOutput = void> extends IBaseBlockConfig {
    do: Block<TInput | TOutput, TBlockOutput>;
    while: Block<TBlockOutput, TOutput>;
}

// @public
export interface IEntity<I extends `${string}.${string}` = `${string}.${string}`> extends ITarget {
    targetIds: {
        entity_id: I[];
    };
}

// @public
export interface IEventBus {
    emit<ET extends HassBlocksEvent['eventType'], T extends HassBlocksEvent & {
        eventType: ET;
    }>(type: ET, event?: Omit<T, 'id' | 'timestamp' | 'eventType'>): void;
    subscribe(callback: (event: HassBlocksEvent) => void): void;
}

// @public
export interface IfThenElseConditionConfig<TInput, TThenInput, TElseInput, TThenOutput, TElseOutput> extends IBaseBlockConfig {
    readonly assertion: Block<TInput, TThenInput & TElseInput> | Block<TInput, void>;
    readonly else: Block<TElseInput | void, TElseOutput>;
    readonly then: Block<TThenInput | void, TThenOutput>;
}

// @public
export interface IFullBlocksClient extends IHass {
    getAutomations(): IBlock<unknown, unknown>[];
    loadStates(): Promise<void>;
    registerAutomation(...automation: IBlock<unknown, unknown>[]): Promise<void>;
    registerTrigger(trigger: Record<string, unknown>, callback: (event: unknown) => void | Promise<void>): Promise<void>;
}

// @public
export interface IHass {
    callService(params: Omit<ICallServiceParams, 'id' | 'type'>): Promise<State[]>;
    getAreas(): Promise<HassArea[]>;
    getEntity(id: string): HassEntity;
    getServices(): Promise<Record<string, Record<string, Service>>>;
    getState(id: string): string;
}

// @public
export interface ILogger {
    debug(message: string): void;
    error(message: string): void;
    fatal: (message: string) => void;
    info(message: string): void;
    trace(message: string): void;
    warn(message: string): void;
}

// @public
export interface ILoopConfig<TInput = void, TOutput = void, TBlockOutput = void> extends IBaseBlockConfig {
    then: Block<TOutput, TBlockOutput>;
    while: Block<TInput | TBlockOutput, TOutput>;
}

// @public
export const initialiseBlocks: (args?: IBlocksConfig) => Promise<IBlocksConnection>;

// @public
export type InputType<T extends Block<unknown, unknown>> = void extends RawInputType<T> ? undefined extends RawInputType<T> ? Exclude<RawInputType<T>, undefined> : RawInputType<T> : RawInputType<T>;

// @public
export interface IPluginArgs {
    client: IFullBlocksClient;
    config: HassConfig;
    events: IEventBus;
}

// @public
export interface ITarget {
    initialise(hass: IFullBlocksClient, mqtt: IMQTTConnection): Promise<void>;
    targetIds: ITargetIds;
}

// @public
export interface ITargetIds {
    area_id?: string[];
    device_id?: string[];
    entity_id?: string[];
}

// @public
export interface ITrigger extends IBlocksNode {
    attachToClient(client: IFullBlocksClient, block: IBlock<unknown, unknown>, events: IEventBus): Promise<void>;
}

// @public
export interface ITriggerConfig {
    id?: string;
    name: string;
    targets?: ITarget[];
    trigger: Record<string, unknown>;
}

// @public
interface LifeCycleEvent<T extends string> extends BaseHassBlocksEvent<T> {
    block: SerialisedBlock;
    executeId: string;
    name: string;
    triggerId: string;
}
export { LifeCycleEvent as BaseHassEvent }
export { LifeCycleEvent }

// @public
export interface LoadPluginFinished extends BaseHassBlocksEvent<'load-plugin-finished'> {
    name: string;
}

// @public
export interface LoadPluginsFinished extends BaseHassBlocksEvent<'load-plugins-finished'> {
    plugins: string[];
}

// @public
export type LoadPluginsStart = BaseHassBlocksEvent<'load-plugins-started'>;

// @public
export interface LoadPluginStart extends BaseHassBlocksEvent<'load-plugin-started'> {
    name: string;
}

// @public
export interface LogEvent extends BaseHassBlocksEvent<'log-event'> {
    level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
    message: string;
    module: string;
}

// @public
export function loop<TInput = void, TOutput = void, TBlockOutput = void>(config: ILoopConfig<TInput, TOutput, TBlockOutput>): Block<TInput, TOutput>;

// @public
export function loop<TInput = void, TOutput = void, TBlockOutput = void>(config: IDoWhileConfig<TInput, TOutput, TBlockOutput>): Block<TInput, TOutput>;

// @public
export type MultiPassSequence<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TInput, TOutput> = TSequence extends readonly [
infer First extends Block<Pass, Pass>,
infer Next extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? BlockTypeIsCompatibleWithSequence<InputType<Next>, TInput> extends true ? DoRecurse<OutputType<Next>, TOutput, Rest, [...TBefore, First, Next]> : Next extends Block<Pass, Pass> ? DoRecurse<TInput, TOutput, Rest, [...TBefore, First, Next]> : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'Multi pass sequence not compatible'> : never;

// @public
export type MustIncludeUndefined<T> = undefined extends T ? T : never;

// @public
export type NonPassSequence<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TInput, TOutput> = TSequence extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? BlockTypeIsCompatibleWithSequence<InputType<First>, TInput> extends true ? DoRecurse<OutputType<First>, TOutput, Rest, [...TBefore, First]> : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'General two block sequence - blocks not compatible'> : never;

// @public
export type OutputType<T extends Block<unknown, unknown>> = ExtractOutput<ReturnType<T['run']>>;

// @public
export type OutputTypeKeepPromise<T extends Block<unknown, unknown>> = ExtractOutput<ReturnType<T['run']>>;

// @public
export interface Pass {
    __pass: 'pass';
}

// @public
export type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

// @public
export type RawInputType<T extends Block<unknown, unknown>> = Parameters<T['run']>[1];

// @public
export type RecurseSequence<TCheckOutput extends CheckOutput> = TCheckOutput extends infer Error extends {
    __error: true;
} ? Omit<Error, '__error'> : TCheckOutput extends infer Recurse extends {
    __recurse: true;
    in: unknown;
    out: unknown;
    before: readonly Block<unknown, unknown>[];
    sequence: readonly Block<unknown, unknown>[];
} ? SequenceValidatorRecursive<Recurse['in'], Recurse['out'], Recurse['sequence'], Recurse['before']> : TCheckOutput;

// @public
export const sequence: <const TSequence extends readonly Block<unknown, unknown>[], TInput = GetSequenceInput<TSequence>, TOutput = GetSequenceOutput<TSequence>>(...actions: BlockRetainType<TSequence> & TSequence & ValidateSequence<TInput, TOutput, TSequence>) => Block<TInput, TOutput>;

// @public
export interface SequenceAborted extends LifeCycleEvent<'sequence-aborted'> {
    block: SerialisedBlock;
    name: string;
    type: string;
}

// @public
export type SequenceCompatibilityError<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TMessage extends string> = {
    message: TMessage;
    sequence: {
        input: TInput;
        output: TOutput;
    };
    context: {
        head: TSequence;
        tail: TBefore;
    };
    __error: true;
};

// @public
export type SequenceValidatorRecursive<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[] = []> = TSequence extends [] ? TBefore : RecurseSequence<CheckScenarios<TInput, TOutput, TSequence, TBefore>>;

// @public
export interface SerialisedBlock {
    id: string;
    name: string;
    params?: Record<string, unknown>;
    type: string;
}

// @public
export const serviceCall: <P>(serviceConfig: {
    name: string;
    target?: ITarget;
    params: Omit<CallServiceCommand<P>, "id" | "type">;
}) => Block<Partial<ServiceCallArgs<P>> | undefined, void>;

// @public
export type ServiceCallArgs<P> = {
    target?: ITarget;
    params: Omit<CallServiceCommand<P>, 'id' | 'type' | 'target'>;
};

// @public
export type SingleGeneralBlock<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TInput, TOutput> = TSequence extends readonly [infer Only extends Block<unknown, unknown>] ? BlockTypeIsCompatibleWithSequence<InputType<Only>, TInput> extends true ? BlockTypeIsCompatibleWithSequence<OutputType<Only>, TOutput> extends true ? readonly [...TBefore, Only] : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'Single block sequence - block output not compatible with sequence output'> : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'Single block sequence - block input not compatible with sequence input'> : never;

// @public
export type SinglePassBlock<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = TSequence extends readonly [infer Only extends Block<Pass, Pass>] ? readonly [...TBefore, Only] : never;

// @public
export interface StateChanged extends BaseHassBlocksEvent<'hass-state-changed'> {
    entity: string;
    hassEvent: Event_2;
}

// @public
export interface StopOutput {
    continue: false;
}

// @public
export interface SwitchConfig<TId extends `switch.${string}`> {
    create: false;
    id: TId;
}

// @public
export interface SwitchConfigForCreation<TId extends `switch.${string}`> {
    create: true;
    friendlyName: string;
    id: TId;
}

// @public
export function toggle<TId extends `switch.${string}`>(config: SwitchConfig<TId> | SwitchConfigForCreation<TId>): IEntity<TId>;

// @public
export function toggle<TId extends `switch.${string}`>(id: TId): IEntity<TId>;

// @public
export const trigger: (config: ITriggerConfig) => ITrigger;

// @public
export type TwoPassBlocks<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = TSequence extends readonly [
infer First extends Block<Pass, Pass>,
infer Next extends Block<unknown, unknown>
] ? readonly [...TBefore, First, Next] : never;

// @public
export type ValidateSequence<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends Block<unknown, unknown>[] = []> = Prettify<SequenceValidatorRecursive<TInput, TOutput, TSequence, TBefore>>;

// @public
export const when: <TInput, TThenInput, TElseInput, TThenOutput, TElseOutput>(assertion: IfThenElseConditionConfig<TInput, TThenInput, TElseInput, TThenOutput, TElseOutput>["assertion"], config: Omit<IfThenElseConditionConfig<TInput, TThenInput, TElseInput, TThenOutput, TElseOutput>, "assertion" | "name">) => Block<TInput, TThenOutput | TElseOutput>;

```
