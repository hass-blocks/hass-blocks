## API Report File for "@hass-blocks/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { CallServiceCommand } from '@hass-blocks/hass-ts';
import type { Event as Event_2 } from '@hass-blocks/hass-ts';
import type { HassArea } from '@hass-blocks/hass-ts';
import type { HassConfig } from '@hass-blocks/hass-ts';
import { IHomeAssistant } from '@hass-blocks/hass-ts';
import type { IMQTTConnection } from '@hass-blocks/hass-mqtt';
import type { Service } from '@hass-blocks/hass-ts';
import type { State } from '@hass-blocks/hass-ts';

// @public
export const action: <TInput = void, TOutput = void>(config: IActionConfig<TInput, TOutput>) => Block<TInput, TOutput>;

// @public
export const area: <I extends string>(id: I, name?: string) => IArea<I>;

// @public
export const assertion: <TInput = void, TOutput = void>(config: IAssertionConfig<TInput, TOutput>) => Block<TInput, TOutput>;

// @public
export const automation: <const TSequence extends readonly Block<unknown, unknown>[], TInput = GetSequenceInput<TSequence>, TOutput = GetSequenceOutput<TSequence>>(config: IAutomationConfig<TSequence, TInput, TOutput>) => Block<TInput, TOutput>;

// @public
export interface AutomationRegistered extends BaseHassBlocksEvent<'automation-registered'> {
    block: IBlocksNode;
    name: string;
}

// @public
export interface BaseHassBlocksEvent<T extends string> {
    eventType: T;
    id: string;
    timestamp: string;
}

// @public
export abstract class Block<I = void, O = void> implements IBlock<I, O>, IMutableNode {
    constructor(
    id: string, targets: ITarget[] | undefined,
    _trigger?: (ITrigger | ITrigger[]) | undefined);
    addChild(...node: IMutableNode[]): void;
    addNext(node?: IMutableNode): void;
    readonly children: IMutableNode[];
    protected hasTrigger(): boolean;
    readonly id: string;
    initialise(client: IFullBlocksClient, mqtt: IMQTTConnection): Promise<void>;
    linkNodes(...nodes: IMutableNode[]): void;
    abstract readonly name: string;
    abstract run(context: IRunContext<I>): Promise<BlockOutput<O>> | BlockOutput<O>;
    toJson(): IBlocksNode;
    get trigger(): ITrigger | ITrigger[];
    set trigger(trigger: ITrigger | ITrigger[]);
    abstract readonly type: string;
}

// @public
export interface BlockFailed extends LifeCycleEvent<'block-failed'> {
    error: Error;
    message: string;
    parent?: IBlocksNode;
    type: string;
}

// @public
export interface BlockFinished<O = unknown> extends LifeCycleEvent<'block-finished'> {
    output: BlockOutput<O>;
    parent?: IBlocksNode;
    type: string;
}

// @public
export type BlockOutput<O> = ContinueOutput<O> | StopOutput | ConditionResult<O>;

// @public
export interface BlockPending extends LifeCycleEvent<'block-pending'> {
    parent?: IBlocksNode;
    triggeredBy?: ITrigger;
    type: string;
}

// @public
export type BlockRetainType<A extends readonly Block<unknown, unknown>[]> = A extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? readonly [
Block<InputType<First>, OutputTypeKeepPromise<First>>,
...BlockRetainType<Rest>
] : readonly [];

// @public
export interface BlockStarted extends LifeCycleEvent<'block-started'> {
    parent?: IBlocksNode;
    triggeredBy?: ITrigger;
    type: string;
}

// @public
export type BlockTypeIsCompatibleWithSequence<TFirstBlock, TSequenceInput> = [
Exclude<TFirstBlock, undefined>
] extends [
TSequenceInput extends void ? MustIncludeUndefined<TFirstBlock> : Partial<TSequenceInput>
] ? true : false;

// @public
export type CheckOutput = readonly Block<unknown, unknown>[] | DoRecurse<unknown, unknown, readonly Block<unknown, unknown>[], readonly Block<unknown, unknown>[]> | SequenceCompatibilityError<unknown, unknown, readonly Block<unknown, unknown>[], readonly Block<unknown, unknown>[], string>;

// @public
export type CheckScenarios<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = SinglePassBlock<TSequence, TBefore> extends never ? SingleGeneralBlock<TSequence, TBefore, TInput, TOutput> extends never ? TwoPassBlocks<TSequence, TBefore> extends never ? MultiPassSequence<TSequence, TBefore, TInput, TOutput> extends never ? NonPassSequence<TSequence, TBefore, TInput, TOutput> extends never ? SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'No compatible sequences found'> : NonPassSequence<TSequence, TBefore, TInput, TOutput> : MultiPassSequence<TSequence, TBefore, TInput, TOutput> : TwoPassBlocks<TSequence, TBefore> : SingleGeneralBlock<TSequence, TBefore, TInput, TOutput> : SinglePassBlock<TSequence, TBefore>;

// @public
export const combine: <T extends ReadonlyArray<IArea> | ReadonlyArray<IEntity> | ReadonlyArray<IDevice>>(...items: T) => T[number];

// @public
export const concurrently: <TCollectionOfBlocks extends readonly Block<unknown, unknown>[]>(...actions: TCollectionOfBlocks) => Block<GetSequenceInput<TCollectionOfBlocks>, GetSequenceOutput<TCollectionOfBlocks>[]>;

// @public
export interface ConditionResult<O> {
    conditionResult: boolean;
    continue: true;
    output: O;
    outputType: 'conditional';
}

// @public
export interface ContinueOutput<O> {
    continue: true;
    output: O;
    outputType: 'block';
}

// @public
export type DoRecurse<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = {
    __recurse: true;
    in: TInput;
    out: TOutput;
    sequence: TSequence;
    before: TBefore;
};

// @public
export const entity: <I extends `${string}.${string}`>(id: I, friendlyName?: string) => IEntity<I>;

// @public
export class ExecutionAbortedError extends HassBlocksError {
    constructor(name: string);
}

// @public
export enum ExecutionMode {
    Parallel = "Parallel",
    Queue = "Queue",
    Restart = "Restart"
}

// @public
export type ExtractOutput<TAny> = TAny extends Promise<infer TPromiseType> ? ExtractOutput<TPromiseType> : TAny extends Exclude<BlockOutput<infer TBlockType>, StopOutput> ? TBlockType : never;

// @public
export interface GeneralFailure extends BaseHassBlocksEvent<'generalFailure'> {
    error: Error;
    message: string;
}

// @public
export type GetOutputs<T extends readonly Block<unknown, unknown>[]> = T extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends Block<unknown, unknown>[]
] ? readonly [OutputType<First>, ...GetOutputs<Rest>] : readonly [];

// @public
export type GetSequenceInput<T extends ReadonlyArray<unknown>> = T extends readonly [Block<Pass, Pass>] ? Pass : T extends readonly [infer Only extends Block<unknown, unknown>] ? InputType<Only> : T extends readonly [infer First, ...infer Rest] ? First extends Block<Pass, Pass> ? GetSequenceInput<Rest> : First extends Block<unknown, unknown> ? InputType<First> : ['Item wasnt a block'] : ['No valid array remaining'];

// @public
export type GetSequenceOutput<T extends ReadonlyArray<unknown>> = T extends readonly [Block<Pass, Pass>] ? Pass : T extends readonly [infer Only extends Block<unknown, unknown>] ? OutputType<Only> : T extends readonly [...infer Rest, infer Last] ? Last extends Block<Pass, Pass> ? GetSequenceOutput<Rest> : Last extends Block<unknown, unknown> ? OutputType<Last> : ['Item wasnt a block'] : ['No valid arrray remaining'];

// @public
export class HassBlocksError extends Error {
    constructor(message: string, cause?: unknown);
}

// @public
export type HassBlocksEvent = AutomationRegistered | GeneralFailure | LogEvent | StateChanged | BlockFailed | BlockFinished | BlockPending | BlockStarted | SequenceAborted | LoadPluginsStart | LoadPluginStart | LoadPluginsFinished | LoadPluginFinished;

// @public
export type HassContext = {
    id: string;
    user_id: string | null;
    parent_id: string | null;
};

// @public
export type HassEntity = HassEntityBase & {
    attributes: {
        [key: string]: any;
    };
};

// @public
export type HassEntityAttributeBase = {
    friendly_name?: string;
    unit_of_measurement?: string;
    icon?: string;
    entity_picture?: string;
    supported_features?: number;
    hidden?: boolean;
    assumed_state?: boolean;
    device_class?: string;
    state_class?: string;
    restored?: boolean;
};

// @public
export type HassEntityBase = {
    entity_id: string;
    state: string;
    last_changed: string;
    last_updated: string;
    attributes: HassEntityAttributeBase;
    context: HassContext;
};

// @public
export type HassEventBase = {
    origin: string;
    time_fired: string;
    context: HassContext;
};

// @public
export interface IActionConfig<TInput = void, TOutput = void> extends IBaseBlockConfig {
    callback: ((context: IRunContext<TInput>) => TOutput) | ((context: IRunContext<TInput>) => Promise<TOutput>);
}

// @public
export interface IAddable {
    addChild(...node: IMutableNode[]): void;
    addNext(...node: IMutableNode[]): void;
}

// @public
export interface IArea<I extends string = string> extends ITarget {
    targetIds: {
        area_id: I[];
    };
}

// @public
export interface IAssertionConfig<TInput, TOutput> extends IBaseBlockConfig {
    readonly predicate: (context: IRunContext<TInput>) => Promise<boolean> | boolean | {
        result: boolean;
        output: TOutput;
    } | Promise<{
        result: boolean;
        output: TOutput;
    }>;
}

// @public
export interface IAutomationConfig<TSequence extends readonly Block<unknown, unknown>[], TInput = GetSequenceInput<TSequence>, TOutput = GetSequenceOutput<TSequence>> extends IBaseBlockConfig {
    mode?: ExecutionMode;
    then: (BlockRetainType<TSequence> & TSequence & ValidateSequence<TInput, TOutput, TSequence>) | Block<TInput, TOutput>;
    when?: ITrigger | ITrigger[];
}

// @public
export interface IBaseBlockConfig {
    readonly id?: string;
    readonly name: string;
    readonly targets?: ITarget[];
}

// @public
export interface IBlock<I = void, O = void> extends IBlocksNode {
    run(context: IRunContext<I>): Promise<BlockOutput<O>> | BlockOutput<O>;
    trigger: ITrigger | ITrigger[];
    type: string;
}

// @public
export interface IBlocksConfig {
    client?: IHomeAssistant;
    logger?: ILogger;
    plugins?: IBlocksPlugin[];
}

// @public
export interface IBlocksConnection {
    registry: IBlocksRegistry;
}

// @public
export interface IBlocksNode {
    children: IBlocksNode[];
    id: string;
    name: string;
    params?: Record<string, unknown>;
    type: string;
}

// @public
export interface IBlocksPlugin {
    load(args: IPluginArgs): Promise<void>;
    readonly name: string;
}

// @public
export interface IBlocksRegistry {
    registerAutomation(...automation: (IMutableNode & ITriggerable)[]): Promise<void>;
}

// @public
export interface ICallServiceParams {
    data?: Record<string, unknown>;
    domain: string;
    service: string;
    target?: {
        entity_id?: string | string[];
        area_id?: string | string[];
        device_id?: string | string[];
    };
}

// @public
export interface IDevice extends ITarget {
    targetIds: {
        device_id: string[];
    };
}

// @public
export interface IDoWhileConfig<TInput = void, TOutput = void, TBlockOutput = void> extends IBaseBlockConfig {
    do: Block<TInput | TOutput, TBlockOutput>;
    while: Block<TBlockOutput, TOutput>;
}

// @public
export interface IEntity<I extends `${string}.${string}` = `${string}.${string}`> extends ITarget {
    currentState: HassEntity;
    targetIds: {
        entity_id: I[];
    };
}

// @public
export interface IEventBus {
    emit<ET extends HassBlocksEvent['eventType'], T extends HassBlocksEvent & {
        eventType: ET;
    }>(type: ET, event?: Omit<T, 'id' | 'timestamp' | 'eventType'>): void;
    subscribe(callback: (event: HassBlocksEvent) => void): void;
}

// @public
export interface IfThenElseConditionConfig<TInput, TThenInput, TElseInput, TThenOutput, TElseOutput> extends IBaseBlockConfig {
    readonly assertion: Block<TInput, TThenInput & TElseInput> | Block<TInput, void>;
    readonly else: Block<TElseInput | void, TElseOutput>;
    readonly then: Block<TThenInput | void, TThenOutput>;
}

// @public
export interface IFullBlocksClient extends IHass {
    getAutomations(): (IBlocksNode & ISerialisable)[];
    loadStates(): Promise<void>;
    onStateChanged(id: string, callback: (event: Event_2) => void): Promise<void>;
    registerAutomation(...automation: (IMutableNode & ITriggerable)[]): Promise<void>;
    registerTrigger(trigger: Record<string, unknown>, callback: (event: unknown) => void | Promise<void>): Promise<void>;
}

// @public
export interface IHass {
    callService(params: Omit<ICallServiceParams, 'id' | 'type'>): Promise<State[]>;
    getAreas(): Promise<HassArea[]>;
    getEntity(id: string): HassEntity;
    getEntity(entity: IEntity<`${string}.${string}`>): HassEntity;
    getServices(): Promise<Record<string, Record<string, Service>>>;
    getState(id: string): string;
    getState(entity: IEntity<`${string}.${string}>`>): string;
    getStates(): Map<string, HassEntity>;
}

// @public
export interface IInitialisable {
    initialise(client: IHass, mqtt: IMQTTConnection): Promise<void>;
}

// @public
export interface ILogger {
    debug(message: string): void;
    error(message: string): void;
    fatal: (message: string) => void;
    info(message: string): void;
    trace(message: string): void;
    warn(message: string): void;
}

// @public
export interface ILoopConfig<TInput = void, TOutput = void, TBlockOutput = void> extends IBaseBlockConfig {
    then: Block<TOutput, TBlockOutput>;
    while: Block<TInput | TBlockOutput, TOutput>;
}

// @public
export type IMutableNode = IBlocksNode & ISerialisable & IInitialisable & IAddable;

// @public
export const initialiseBlocks: (args?: IBlocksConfig) => Promise<IBlocksConnection>;

// @public
export type InputType<T extends Block<unknown, unknown>> = void extends RawInputType<T> ? RemoveVoidIfNotOnlyVoid<undefined extends RawInputType<T> ? Exclude<RawInputType<T>, undefined> : RawInputType<T>> : RawInputType<T>;

// @public
export interface IPluginArgs {
    client: IFullBlocksClient;
    config: HassConfig;
    events: IEventBus;
    logger: ILogger;
}

// @public
export interface IRunContext<I> {
    events?: IEventBus;
    hass: IHass;
    input: I;
    runner: <TInput, TOutput>(block: Block<TInput, TOutput>) => (input: TInput) => Promise<BlockOutput<TOutput>>;
    triggerId?: string;
}

// @public
export interface ISerialisable {
    toJson(): IBlocksNode;
}

// @public
export interface ITarget {
    initialise(hass: IFullBlocksClient, mqtt: IMQTTConnection): Promise<void>;
    targetIds: ITargetIds;
    toString(): string;
}

// @public
export interface ITargetIds {
    area_id?: string[];
    device_id?: string[];
    entity_id?: string[];
}

// @public
export interface ITrigger extends IMutableNode {
    attachToClient(client: IFullBlocksClient, block: IMutableNode & ITriggerable, events: IEventBus): Promise<void>;
}

// @public
export interface ITriggerable {
    trigger: ITrigger | ITrigger[];
}

// @public
export interface ITriggerConfig {
    id?: string;
    name: string;
    targets?: ITarget[];
    trigger: Record<string, unknown>;
}

// @public
interface LifeCycleEvent<T extends string> extends BaseHassBlocksEvent<T> {
    block: IBlocksNode;
    executeId: string;
    name: string;
    triggerId: string;
}
export { LifeCycleEvent as BaseHassEvent }
export { LifeCycleEvent }

// @public
export interface LoadPluginFinished extends BaseHassBlocksEvent<'load-plugin-finished'> {
    name: string;
}

// @public
export interface LoadPluginsFinished extends BaseHassBlocksEvent<'load-plugins-finished'> {
    plugins: string[];
}

// @public
export type LoadPluginsStart = BaseHassBlocksEvent<'load-plugins-started'>;

// @public
export interface LoadPluginStart extends BaseHassBlocksEvent<'load-plugin-started'> {
    name: string;
}

// @public
export interface LogEvent extends BaseHassBlocksEvent<'log-event'> {
    level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
    message: string;
    module: string;
}

// @public
export function loop<TInput = void, TOutput = void, TBlockOutput = void>(config: ILoopConfig<TInput, TOutput, TBlockOutput>): Block<TInput, TOutput>;

// @public
export function loop<TInput = void, TOutput = void, TBlockOutput = void>(config: IDoWhileConfig<TInput, TOutput, TBlockOutput>): Block<TInput, TOutput>;

// @public
export type MultiPassSequence<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TInput, TOutput> = TSequence extends readonly [
infer First extends Block<Pass, Pass>,
infer Next extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? BlockTypeIsCompatibleWithSequence<InputType<Next>, TInput> extends true ? DoRecurse<OutputType<Next>, TOutput, Rest, [...TBefore, First, Next]> : Next extends Block<Pass, Pass> ? DoRecurse<TInput, TOutput, Rest, [...TBefore, First, Next]> : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'Multi pass sequence not compatible'> : never;

// @public
export type MustIncludeUndefined<T> = undefined extends T ? T : never;

// @public
export type NonPassSequence<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TInput, TOutput> = TSequence extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? BlockTypeIsCompatibleWithSequence<InputType<First>, TInput> extends true ? DoRecurse<OutputType<First>, TOutput, Rest, [...TBefore, First]> : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'General two block sequence - blocks not compatible'> : never;

// @public
export type OutputType<T extends Block<unknown, unknown>> = ExtractOutput<ReturnType<T['run']>>;

// @public
export type OutputTypeKeepPromise<T extends Block<unknown, unknown>> = ExtractOutput<ReturnType<T['run']>>;

// @public
export interface Pass {
    __pass: 'pass';
}

// @public
export type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

// @public
export type RawInputType<T extends Block<unknown, unknown>> = Parameters<T['run']>[0]['input'];

// @public
export type RecurseSequence<TCheckOutput extends CheckOutput> = TCheckOutput extends infer Error extends {
    __error: true;
} ? Omit<Error, '__error'> : TCheckOutput extends infer Recurse extends {
    __recurse: true;
    in: unknown;
    out: unknown;
    before: readonly Block<unknown, unknown>[];
    sequence: readonly Block<unknown, unknown>[];
} ? SequenceValidatorRecursive<Recurse['in'], Recurse['out'], Recurse['sequence'], Recurse['before']> : TCheckOutput;

// @public
export type RemoveVoidIfNotOnlyVoid<T> = Exclude<T, void> extends never ? void : Exclude<T, void>;

// @public
export const sequence: <const TSequence extends readonly Block<unknown, unknown>[], TInput = GetSequenceInput<TSequence>, TOutput = GetSequenceOutput<TSequence>>(...actions: BlockRetainType<TSequence> & TSequence & ValidateSequence<TInput, TOutput, TSequence>) => Block<TInput, TOutput>;

// @public
export interface SequenceAborted extends LifeCycleEvent<'sequence-aborted'> {
    block: IBlocksNode;
    name: string;
    type: string;
}

// @public
export type SequenceCompatibilityError<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TMessage extends string> = {
    message: TMessage;
    sequence: {
        input: TInput;
        output: TOutput;
    };
    context: {
        head: TBefore;
        tail: TSequence;
    };
    __error: true;
};

// @public
export type SequenceValidatorRecursive<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[] = []> = TSequence extends [] ? TBefore : RecurseSequence<CheckScenarios<TInput, TOutput, TSequence, TBefore>>;

// @public
export const serviceCall: <P>(serviceConfig: {
    name: string;
    target?: ITarget;
    params: Omit<CallServiceCommand<P>, "id" | "type">;
}) => Block<Partial<P> | undefined, void>;

// @public
export type ServiceCallArgs<P> = {
    target?: ITarget;
    params: Omit<CallServiceCommand<P>, 'id' | 'type' | 'target'>;
};

// @public
export type SingleGeneralBlock<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[], TInput, TOutput> = TSequence extends readonly [infer Only extends Block<unknown, unknown>] ? BlockTypeIsCompatibleWithSequence<InputType<Only>, TInput> extends true ? BlockTypeIsCompatibleWithSequence<OutputType<Only>, TOutput> extends true ? readonly [...TBefore, Only] : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'Single block sequence - block output not compatible with sequence output'> : SequenceCompatibilityError<TInput, TOutput, TSequence, TBefore, 'Single block sequence - block input not compatible with sequence input'> : never;

// @public
export type SinglePassBlock<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = TSequence extends readonly [infer Only extends Block<Pass, Pass>] ? readonly [...TBefore, Only] : never;

// @public
export interface StateChanged extends BaseHassBlocksEvent<'hass-state-changed'> {
    entity: string;
    hassEvent: Event_2;
}

// @public
export interface StopOutput {
    continue: false;
}

// @public
export interface SwitchConfig<TId extends `switch.${string}`> {
    create: false;
    id: TId;
}

// @public
export interface SwitchConfigForCreation<TId extends `switch.${string}`> {
    create: true;
    friendlyName: string;
    id: TId;
}

// @public
export function toggle<TId extends `switch.${string}`>(config: SwitchConfig<TId> | SwitchConfigForCreation<TId>): IEntity<TId>;

// @public
export function toggle<TId extends `switch.${string}`>(id: TId): IEntity<TId>;

// @public
export const trigger: (config: ITriggerConfig) => ITrigger;

// @public
export type TwoPassBlocks<TSequence extends readonly Block<unknown, unknown>[], TBefore extends readonly Block<unknown, unknown>[]> = TSequence extends readonly [
infer First extends Block<Pass, Pass>,
infer Next extends Block<unknown, unknown>
] ? readonly [...TBefore, First, Next] : never;

// @public
export type ValidateSequence<TInput, TOutput, TSequence extends readonly Block<unknown, unknown>[], TBefore extends Block<unknown, unknown>[] = []> = Prettify<SequenceValidatorRecursive<TInput, TOutput, TSequence, TBefore>>;

// @public
export const when: <TInput, TThenInput, TElseInput, TThenOutput, TElseOutput>(assertion: IfThenElseConditionConfig<TInput, TThenInput, TElseInput, TThenOutput, TElseOutput>["assertion"], config: Omit<IfThenElseConditionConfig<TInput, TThenInput, TElseInput, TThenOutput, TElseOutput>, "assertion" | "name">) => Block<TInput, TThenOutput | TElseOutput>;

```
