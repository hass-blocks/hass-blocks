import type { ITrigger } from './i-trigger.ts';
import type { StateChangedEvent } from '@hass-blocks/hass-ts';
import type { BlockOutput } from './block-output.ts';
import type { IBlocksNode } from './i-blocks-node.ts';

/**
 * @public
 *
 * Events published by the framework on the event bus
 */
export type HassBlocksEvent =
  | AutomationRegistered
  | GeneralFailure
  | LogEvent
  | StateChanged
  | BlockFailed
  | BlockFinished
  | BlockPending
  | BlockStarted
  | SequenceAborted
  | LoadPluginsStart
  | LoadPluginStart
  | LoadPluginsFinished
  | LoadPluginFinished;

/**
 * @public
 *
 * An event emitted whenever you want to log information. Will be picked up by
 * logging clients
 */
export interface LogEvent extends BaseHassBlocksEvent<'log-event'> {
  /**
   * The log message
   */
  message: string;

  /**
   * The module that emitted the log message
   */
  module: string;

  /**
   * The log level
   */
  level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
}

/**
 * @public
 *
 * An event that is emitted just before all plugins start loading
 */
export type LoadPluginsStart = BaseHassBlocksEvent<'load-plugins-started'>;

/**
 * @public
 *
 * An event that is emitted just before a specific plugin starts loading
 */
export interface LoadPluginStart
  extends BaseHassBlocksEvent<'load-plugin-started'> {
  /**
   * The name of the plugin that is about to start loading
   */
  name: string;
}

/**
 * @public
 *
 * An event that is emitted just after a specific plugin finishes loading
 */
export interface LoadPluginFinished
  extends BaseHassBlocksEvent<'load-plugin-finished'> {
  /**
   * The name of the plugin that finished loading
   */
  name: string;
}

/**
 * @public
 *
 * An event that is emitted after all plugins have finished loading
 */
export interface LoadPluginsFinished
  extends BaseHassBlocksEvent<'load-plugins-finished'> {
  /**
   * A loist of plugins that were loaded
   */
  plugins: string[];
}

/**
 * @public
 *
 * An event that is emitted when the websocket client recieves a state change from Hass
 */
export interface StateChanged
  extends BaseHassBlocksEvent<'hass-state-changed'> {
  /**
   * The entity that changed state
   */
  entity: string;

  /**
   * The raw event data from Home Assistant
   */
  hassEvent: StateChangedEvent;
}

/**
 * @public
 *
 * The base event that all events fired by the framework inherit from
 */
export interface BaseHassBlocksEvent<T extends string> {
  /**
   * The type of the event that was fired - used for discriminating unions
   */
  eventType: T;

  /**
   * The id of the individual event - generated at the time of emit
   */
  id: string;

  /**
   * The time that the event was emitted
   */
  timestamp: string;
}

/**
 * @public
 *
 * All events that relate to the lifecycle of a block inherit from this event
 */
export interface LifeCycleEvent<T extends string>
  extends BaseHassBlocksEvent<T> {
  /**
   * A unique uuid generated each time a trigger is fired. All blocks that are executed
   * as a result of that trigger will get the same triggerId
   */
  triggerId: string;

  /**
   * A unique uuid that is generated for all events associated with a single execution of a given
   * block. This uuid is different every time the block is executed but the same for all of the lifecycle
   * events associated with that execution
   */
  executeId: string;

  /**
   * The name of the block being executed
   */
  name: string;

  /**
   * A serialised version of the block being executed
   */
  block: IBlocksNode;
}

/**
 * @public
 *
 * An event that is emitted when an automation has been registered
 */
export interface AutomationRegistered
  extends BaseHassBlocksEvent<'automation-registered'> {
  /**
   * The name of the automation that was registered
   */
  name: string;

  /**
   * A serialised version of the block that was registered
   */
  block: IBlocksNode;
}

/**
 * @public
 *
 * An event that is emitted when there is some kind of error
 */
export interface GeneralFailure extends BaseHassBlocksEvent<'generalFailure'> {
  /**
   * The message string that was generated by the error
   */
  message: string;

  /**
   * The original error object
   */
  error: Error;
}

/**
 * @public
 *
 * An event that is emitted when a block starts executing
 */
export interface BlockStarted extends LifeCycleEvent<'block-started'> {
  /**
   * The type of block that has started
   */
  type: string;

  /**
   * The parent block (often this will be the automation that triggered the block execution)
   */
  parent?: IBlocksNode;

  /**
   * The trigger object that started this execution sequence
   */
  triggeredBy?: ITrigger;
}

/**
 * @public
 *
 * An event that is emitted when a block finishes successfully
 */
export interface BlockFinished<O = unknown>
  extends LifeCycleEvent<'block-finished'> {
  /**
   * The type of block that has started
   */
  type: string;

  /**
   * The output that was returned by the block callback
   */
  output: BlockOutput<O>;

  /**
   * The parent block (often this will be the automation that triggered the block execution)
   */
  parent?: IBlocksNode;
}

/**
 * @public
 *
 * An event that is emitted when a block fails for some reason
 */
export interface BlockFailed extends LifeCycleEvent<'block-failed'> {
  /**
   * The type of block that failed
   */
  type: string;

  /**
   * The message that explains why the block failed
   */
  message: string;

  /**
   * The original error object
   */
  error: Error;

  /**
   * The parent block (often this will be the automation that triggered the block execution)
   */
  parent?: IBlocksNode;
}

/**
 * @public
 *
 * An event that is emitted when a block is queued for execution
 */
export interface BlockPending extends LifeCycleEvent<'block-pending'> {
  /**
   * The type of block that was queued
   */
  type: string;

  /**
   * The parent block (often this will be the automation that triggered the block execution)
   */
  parent?: IBlocksNode;

  /**
   * The trigger object that started this execution sequence
   */
  triggeredBy?: ITrigger;
}

/**
 * @public
 *
 * An event that is emitted when a sequence is aborted for some reason
 */
export interface SequenceAborted extends LifeCycleEvent<'sequence-aborted'> {
  /**
   * The type of block that was aborted
   */
  type: string;

  /**
   * A serialised version of the block that caused the sequence to be aborted
   */
  block: IBlocksNode;

  /**
   * The name of the block that caused the sequence to be aborted
   */
  name: string;
}
